# Отчёт по лабораторной работе №2

## Тема

Параллельное программирование в Python: threading, multiprocessing, async.

## Цель работы

Изучить различные подходы к параллельному выполнению задач в Python, сравнить их работу на примере:

1. Вычислений суммы большого диапазона чисел (CPU-bound).
2. Параллельного парсинга веб-страниц с сохранением данных в базу (I/O-bound).

# Задача 1. Различия между threading, multiprocessing и async

## Условие

Посчитать сумму всех чисел от 1 до N (N = 10\*\*8), разделив задачу на несколько параллельных подзадач.

## Реализация

- **Threading**: создано несколько потоков, каждый считает часть диапазона.
- **Multiprocessing**: использован пул процессов, каждый процесс работает независимо.
- **Asyncio**: асинхронные задачи с `run_in_executor`, чтобы выполнять CPU-bound код.

## Результаты времени выполнения

| Подход              | Время, сек |
| ------------------- | ---------: |
| **Threading**       |      ~3.88 |
| **Asyncio**         |      ~4.06 |
| **Multiprocessing** |      ~1.36 |

> **Вывод:** `multiprocessing` выполняет задачу примерно в 3–4 раза быстрее, потому что использует все ядра и не ограничен GIL. Потоки и asyncio не дают ускорения для чисто вычислительных операций.

# Задача 2. Параллельный парсинг веб-страниц

## Условие

Написать программу для параллельного парсинга HTML-страниц, извлечения `<title>` и сохранения данных в PostgreSQL.

## Реализация

- **Threading**: для каждого URL создаётся поток. Подходит для I/O-задач.
- **Multiprocessing**: пул процессов. Есть лишние накладные расходы.
- **Asyncio + aiohttp**: запросы выполняются асинхронно в одном потоке.

## Результаты времени выполнения

Для 5 веб-сайтов, при хорошем соединении (примерные значения):

| Подход              | Время, сек |
| ------------------- | ---------: |
| **Threading**       |      ~3.00 |
| **Asyncio**         |      ~3.04 |
| **Multiprocessing** |      ~3.49 |

> **Вывод:** на сетевых задачах выигрывают `asyncio` и `threading`, так как могут перекрывать ожидание ответов от серверов. `multiprocessing` даёт избыточный overhead и немного дольше запускается.

# Выводы

1. Для **CPU-bound задач** (чистые вычисления) наилучший выбор — `multiprocessing`, так как процессы работают параллельно на всех ядрах и не зависят от GIL.
2. Для **I/O-bound задач** (сетевые запросы, работа с файлами, БД) оптимальны `asyncio` и `threading`, которые позволяют перекрывать ожидание.
3. Универсального подхода нет — нужно выбирать технологию под задачу.
4. Работа показала на практике ключевое различие:
   - `threading` — лёгкие потоки, но ограничены GIL для вычислений.
   - `multiprocessing` — реальные параллельные вычисления.
   - `asyncio` — масштабируемость и высокая эффективность в сетевых задачах.
